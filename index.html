<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Interactive Fidgets Zone</title>
<style>
  body {
    margin: 0;
    background: radial-gradient(circle at top, #222, #111);
    font-family: 'Poppins', sans-serif;
    overflow: hidden;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    user-select: none;
  }
  h1 {
    font-weight: 600;
    margin-bottom: 10px;
  }
  .container {
    display: flex;
    gap: 40px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
  }
  canvas {
    background: #1b1b1b;
    border-radius: 20px;
    box-shadow: 0 0 20px rgba(255,255,255,0.1);
  }
  button {
    background: #444;
    color: white;
    border: none;
    border-radius: 10px;
    padding: 10px 20px;
    font-size: 1rem;
    cursor: pointer;
    margin-top: 15px;
    transition: background 0.3s;
  }
  button:hover {
    background: #666;
  }
</style>
</head>
<body>
<h1>Interactive Fidgets Zone</h1>
<div class="container">
  <canvas id="bubbleWrap" width="300" height="300"></canvas>
  <canvas id="spinner" width="250" height="250"></canvas>
  <canvas id="stressBall" width="250" height="250"></canvas>
  <canvas id="sliderCube" width="250" height="250"></canvas>
</div>
<button id="reset">Reset Bubble Wrap</button>
<audio id="squishSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_d1b8c0792a.mp3?filename=squish-2-96212.mp3"></audio>
<script>
// Bubble Wrap
const bw = document.getElementById('bubbleWrap');
const bwCtx = bw.getContext('2d');
let bubbleSize = 40;
let cols = Math.floor(bw.width / bubbleSize);
let rows = Math.floor(bw.height / bubbleSize);
let popped = Array(cols * rows).fill(false);
function drawBubbles() {
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let idx = j * cols + i;
      let x = i * bubbleSize + bubbleSize / 2;
      let y = j * bubbleSize + bubbleSize / 2;
      bwCtx.beginPath();
      bwCtx.arc(x, y, bubbleSize/2 - 4, 0, Math.PI * 2);
      if (popped[idx]) {
        bwCtx.fillStyle = '#333';
      } else {
        bwCtx.fillStyle = 'linear-gradient(145deg,#444,#222)';
      }
      bwCtx.strokeStyle = '#666';
      bwCtx.lineWidth = 2;
      bwCtx.stroke();
      bwCtx.fill();
    }
  }
}
function popBubble(e) {
  const rect = bw.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const i = Math.floor(x / bubbleSize);
  const j = Math.floor(y / bubbleSize);
  const idx = j * cols + i;
  if (!popped[idx]) {
    popped[idx] = true;
    drawBubbles();
  }
}
bw.addEventListener('mousedown', popBubble);
document.getElementById('reset').addEventListener('click', () => {
  popped.fill(false);
  drawBubbles();
});

// Fidget Spinner
const spinner = document.getElementById('spinner');
const sCtx = spinner.getContext('2d');
let spinAngle = 0, spinVel = 0, spinning = false;
let dragStartAngle, dragging = false;
function drawSpinner() {
  sCtx.clearRect(0,0,spinner.width,spinner.height);
  sCtx.save();
  sCtx.translate(125,125);
  sCtx.rotate(spinAngle);
  sCtx.fillStyle = '#0af';
  for (let i=0;i<3;i++){
    sCtx.beginPath();
    sCtx.arc(80,0,30,0,Math.PI*2);
    sCtx.fill();
    sCtx.rotate((2*Math.PI)/3);
  }
  sCtx.beginPath();
  sCtx.arc(0,0,25,0,Math.PI*2);
  sCtx.fillStyle = '#0cf';
  sCtx.fill();
  sCtx.restore();
  spinAngle += spinVel;
  spinVel *= 0.99;
  requestAnimationFrame(drawSpinner);
}
spinner.addEventListener('mousedown', e => {
  const rect = spinner.getBoundingClientRect();
  const x = e.clientX - rect.left - 125;
  const y = e.clientY - rect.top - 125;
  dragStartAngle = Math.atan2(y,x) - spinAngle;
  dragging = true;
});
window.addEventListener('mouseup',()=> dragging=false);
window.addEventListener('mousemove', e => {
  if(dragging){
    const rect = spinner.getBoundingClientRect();
    const x = e.clientX - rect.left - 125;
    const y = e.clientY - rect.top - 125;
    const newAngle = Math.atan2(y,x);
    const newSpinAngle = newAngle - dragStartAngle;
    spinVel = newSpinAngle - spinAngle;
    spinAngle = newSpinAngle;
  }
});

// Stress Ball (squishy physics)
const sb = document.getElementById('stressBall');
const sbCtx = sb.getContext('2d');
let sbX = 125, sbY = 125, sbR = 60, sbDrag = false;
let deform = 0;
let targetDeform = 0;
function drawStressBall(){
  sbCtx.clearRect(0,0,sb.width,sb.height);
  deform += (targetDeform - deform)*0.2;
  sbCtx.beginPath();
  const gradient = sbCtx.createRadialGradient(sbX - deform*5, sbY - deform*5, sbR*0.3, sbX, sbY, sbR);
  gradient.addColorStop(0, '#f9a');
  gradient.addColorStop(1, '#f77');
  sbCtx.fillStyle = gradient;
  sbCtx.ellipse(sbX, sbY, sbR + deform*10, sbR - deform*5, 0, 0, Math.PI*2);
  sbCtx.fill();
  requestAnimationFrame(drawStressBall);
}
sb.addEventListener('mousedown',e=>{
  const rect=sb.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  if(Math.hypot(x-sbX,y-sbY)<sbR){
    sbDrag=true;
    targetDeform=0.6;
    document.getElementById('squishSound').play();
  }
});
window.addEventListener('mouseup',()=>{
  sbDrag=false;
  targetDeform=0;
});
window.addEventListener('mousemove',e=>{
  if(sbDrag){
    const rect=sb.getBoundingClientRect();
    sbX=e.clientX-rect.left;
    sbY=e.clientY-rect.top;
  }
});

// Slider Cube
const sc = document.getElementById('sliderCube');
const scCtx = sc.getContext('2d');
let cubeX=50, cubeY=100, draggingCube=false;
function drawSliderCube(){
  scCtx.clearRect(0,0,sc.width,sc.height);
  scCtx.fillStyle='#555';
  scCtx.fillRect(40,90,170,70);
  scCtx.fillStyle='#0f0';
  scCtx.fillRect(cubeX, cubeY, 60, 60);
  requestAnimationFrame(drawSliderCube);
}
sc.addEventListener('mousedown',e=>{
  const rect=sc.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  if(x>cubeX&&x<cubeX+60&&y>cubeY&&y<cubeY+60) draggingCube=true;
});
window.addEventListener('mouseup',()=>draggingCube=false);
window.addEventListener('mousemove',e=>{
  if(draggingCube){
    const rect=sc.getBoundingClientRect();
    cubeX=Math.min(Math.max(e.clientX-rect.left-30,40),150);
  }
});

// init
requestAnimationFrame(drawBubbles);
requestAnimationFrame(drawSpinner);
requestAnimationFrame(drawStressBall);
requestAnimationFrame(drawSliderCube);
</script>
</body>
</html>
